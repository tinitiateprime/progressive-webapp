(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,268833,e=>{"use strict";function t({addMessageListener:e,sendMessage:t,onUpdateError:l=console.error}){e(e=>{if("turbopack-connected"===e.type){var n=t;for(let e of r.keys())s(n,JSON.parse(e))}else try{if(Array.isArray(e.data))for(let t=0;t<e.data.length;t++)b(e.data[t]);else b(e.data);if(0!==o.size){for(let e of(y.beforeRefresh(),o.values()))R(e);o.clear(),m()}}catch(e){console.warn("[Fast Refresh] performing full reload\n\nFast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\nYou might have a file which exports a React component but also exports a value that is imported by a non-React component file.\nConsider migrating the non-React component export to a separate file and importing it into both files.\n\nIt is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\nFast Refresh requires at least one parent function component in your React tree."),l(e),location.reload()}});let n=globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS;if(null!=n&&!Array.isArray(n))throw Error("A separate HMR handler was already registered");if(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS={push:([e,r])=>{k({path:e},t,r)}},Array.isArray(n))for(let[e,r]of n)k({path:e},t,r)}let r=new Map;function l(e,t){e(JSON.stringify(t))}function n(e){return JSON.stringify({path:e.path,headers:e.headers||null})}function s(e,t){return l(e,{type:"turbopack-subscribe",...t}),()=>{l(e,{type:"turbopack-unsubscribe",...t})}}let o=new Map;function a(e,t){var r,l;return{type:"EcmascriptMergedUpdate",entries:(r=e.entries,l=t.entries,{...r,...l}),chunks:function(e,t){if(null==e)return t;if(null==t)return e;let r={};for(let[l,n]of Object.entries(e)){let e=t[l];if(null!=e){let t=function(e,t){if("added"!==e.type||"deleted"!==t.type){if("deleted"===e.type&&"added"===t.type){let r=[],l=[],n=new Set(e.modules??[]),s=new Set(t.modules??[]);for(let e of s)n.has(e)||r.push(e);for(let e of n)s.has(e)||l.push(e);if(0===r.length&&0===l.length)return;return{type:"partial",added:r,deleted:l}}if("partial"===e.type&&"partial"===t.type){let r=new Set([...e.added??[],...t.added??[]]),l=new Set([...e.deleted??[],...t.deleted??[]]);if(null!=t.added)for(let e of t.added)l.delete(e);if(null!=t.deleted)for(let e of t.deleted)r.delete(e);return{type:"partial",added:[...r],deleted:[...l]}}if("added"===e.type&&"partial"===t.type){let r=new Set([...e.modules??[],...t.added??[]]);for(let e of t.deleted??[])r.delete(e);return{type:"added",modules:[...r]}}if("partial"===e.type&&"deleted"===t.type){let r=new Set(t.modules??[]);if(null!=e.added)for(let t of e.added)r.delete(t);return{type:"deleted",modules:[...r]}}}}(n,e);null!=t&&(r[l]=t)}else r[l]=n}for(let[e,l]of Object.entries(t))null==r[e]&&(r[e]=l);if(0!==Object.keys(r).length)return r}(e.chunks,t.chunks)}}function i(e,t){throw Error(`Invariant: ${t}`)}let d=["bug","error","fatal"];function u(e,t,r){return(e.indexOf(t)+1||e.length)-(e.indexOf(r)+1||e.length)}let f=new Map,c=["bug","fatal","error","warning","info","log"],p=["parse","resolve","code generation","rendering","typescript","other"];function h(e){e.sort((e,t)=>{let r=u(c,e.severity,t.severity);return 0!==r?r:u(p,e.category,t.category)})}let y={beforeRefresh:()=>{},refresh:()=>{},buildOk:()=>{},issues:e=>{}};function g(e){Object.assign(y,e)}function b(e){switch(h(e.issues),!function(e){let t=n(e.resource);for(let t of e.issues)d.includes(t.severity);e.issues.length>0?f.set(t,e.issues):f.has(t)&&f.delete(t);let r=[],l=new Set;for(let[e,t]of f)for(let e of t)l.has(e.formatted)||(r.push(e),l.add(e.formatted));h(r),y.issues(r)}(e),e.type){case"issues":break;case"partial":let t,r;t=n(e.resource),(r=o.get(t))?r.instruction=function(e,t){let r,l;if(null!=e.chunks?r=null==t.chunks?e.chunks:function(e,t){let r={};for(let[s,o]of Object.entries(e)){let e=t[s];if(null!=e){var l,n;let t=(l=o,n=e,void(("added"!==l.type||"deleted"!==n.type)&&("deleted"!==l.type||"added"!==n.type)&&("partial"===l.type&&i(l.instruction,"Partial updates are unsupported"),"partial"===n.type&&i(n.instruction,"Partial updates are unsupported"))));null!=t&&(r[s]=t)}else r[s]=o}for(let[e,l]of Object.entries(t))null==r[e]&&(r[e]=l);return r}(e.chunks,t.chunks):null!=t.chunks&&(r=t.chunks),null!=e.merged)if(null==t.merged)l=e.merged;else{let r=e.merged[0];for(let t=1;t<e.merged.length;t++)r=a(r,e.merged[t]);for(let e=0;e<t.merged.length;e++)r=a(r,t.merged[e]);l=[r]}else null!=t.merged&&(l=t.merged);return{type:"ChunkListUpdate",chunks:r,merged:l}}(r.instruction,e.instruction):o.set(t,e);break;default:let l=0===o.size;l&&y.beforeRefresh(),R(e),l&&m()}}function m(){y.refresh(),y.buildOk(),globalThis.__NEXT_HMR_CB&&(globalThis.__NEXT_HMR_CB(),globalThis.__NEXT_HMR_CB=null)}function k(e,t,l){let o,a=n(e),i=r.get(a);return i?(i.callbacks.add(l),o=i):(o={callbacks:new Set([l]),unsubscribe:s(t,e)},r.set(a,o)),()=>{o.callbacks.delete(l),0===o.callbacks.size&&(o.unsubscribe(),r.delete(a))}}function R(e){let t=n(e.resource),l=r.get(t);if(l){for(let t of l.callbacks)t(e);"notFound"===e.type&&r.delete(t)}}e.s(["connect",()=>t,"setHooks",()=>g,"subscribeToUpdate",()=>k])}]);